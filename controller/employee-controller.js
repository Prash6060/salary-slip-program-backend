const Employee = require("../model/Employee");

exports.ListEmployee = async (req, res) => {
  try {
    const employees = await Employee.find();

    if (!employees.length) {
      return res.status(404).json({ msg: "No employees found" });
    }

    return res.status(200).json({ data: employees });
  } catch (error) {
    console.error("Error fetching employees:", error);
    return res.status(500).json({ msg: "Server error while fetching employees" });
  }
};

exports.AddEmployee = async (req, res) => {
  try {
    const {
      name,
      role,
      wagePerDay,
      unit,
      active,          // optional, defaults true
      joiningDate,     // required: "dd/mm/yyyy"
      activeAdvance,   // optional, defaults false
    } = req.body;

    // Basic required fields
    if (!name || !role || wagePerDay == null || !unit || !joiningDate) {
      return res.status(400).json({
        msg: "Required fields: name, role, wagePerDay, unit, joiningDate (dd/mm/yyyy)",
      });
    }

    // Validate wagePerDay
    const wageNum = Number(wagePerDay);
    if (!Number.isFinite(wageNum) || wageNum < 0) {
      return res.status(400).json({ msg: "wagePerDay must be a non-negative number" });
    }

    // Validate joiningDate format and logical validity
    if (!isValidDDMMYYYY(joiningDate)) {
      return res.status(400).json({
        msg: "joiningDate must be in dd/mm/yyyy format and be a valid calendar date",
      });
    }

    // Normalize like mongoose pre-save
    const normalizedName = String(name).trim().toUpperCase();

    // Check unique name BEFORE saving
    const existing = await Employee.findOne({ name: normalizedName });
    if (existing) {
      return res.status(409).json({ msg: "Employee full name must be unique" });
    }

    // Build document (employeeCode is auto-generated by pre-save hook)
    const emp = new Employee({
      name: normalizedName,
      role: String(role).trim(),
      wagePerDay: wageNum,
      unit: String(unit).trim(),
      joiningDate: String(joiningDate).trim(),   // dd/mm/yyyy (per requirement)
      activeAdvance: !!activeAdvance,            // default false if undefined
      active: active !== undefined ? !!active : true,
    });

    const saved = await emp.save();
    return res
      .status(201)
      .json({ msg: "Employee added successfully", data: saved });

  } catch (error) {
    // Duplicate key errors
    if (error?.code === 11000) {
      // Could be unique name or employeeCode (very rare)
      if (error?.keyPattern?.name) {
        return res.status(409).json({ msg: "Employee full name must be unique" });
      }
      if (error?.keyPattern?.employeeCode) {
        return res.status(409).json({ msg: "Generated employee code already exists, please retry" });
      }
      return res.status(409).json({ msg: "Duplicate key error", detail: error?.keyValue });
    }

    // Mongoose validation errors
    if (error?.name === "ValidationError") {
      const errs = Object.values(error.errors).map((e) => e.message);
      return res.status(400).json({ msg: "Validation failed", errors: errs });
    }

    console.error("Error adding employee:", error);
    return res
      .status(500)
      .json({ msg: "Server error while adding employee" });
  }
};

/** Utils **/

/**
 * Validate dd/mm/yyyy and ensure it's a real date (e.g., 31/11/2025 is invalid).
 */
function isValidDDMMYYYY(str) {
  // Basic format check
  const m = /^(\d{2})\/(\d{2})\/(\d{4})$/.exec(str);
  if (!m) return false;
  const dd = Number(m[1]);
  const mm = Number(m[2]);
  const yyyy = Number(m[3]);

  if (mm < 1 || mm > 12) return false;
  if (dd < 1 || dd > 31) return false;

  // Construct date using JS Date (month is 0-based)
  const d = new Date(yyyy, mm - 1, dd);
  // Check that Date didn't overflow (JS auto-corrects invalid dates)
  return (
    d.getFullYear() === yyyy &&
    d.getMonth() === mm - 1 &&
    d.getDate() === dd
  );
}

